<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>Eldritch Arts</title>
    
    <!-- Utilities -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        background-color: #050505;
        overflow: hidden;
      }
      canvas {
        touch-action: none;
      }
      @keyframes width {
        0%, 100% { width: 0%; transform: translateX(0); }
        50% { width: 100%; transform: translateX(0); }
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
    </style>
    
    <!-- Import Map for React -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom": "https://esm.sh/react-dom@18.2.0?external=react",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?external=react",
        "react-webcam": "https://esm.sh/react-webcam@7.2.0?external=react,react-dom"
      }
    }
    </script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-presets="typescript,react" data-type="module">
      import React, { useState, useEffect, useRef, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';
      import WebcamModule from 'react-webcam';

      // --- TYPES ---
      
      type ElementType = 'NEUTRAL' | 'FIRE' | 'WATER' | 'THUNDER' | 'WIND';
      type ComboType = 'BLIZZARD' | 'PLASMA' | 'STEAM' | 'TEMPEST' | 'INFERNO' | 'VOID';
      type ParticleType = 'ORB' | 'LEAF' | 'SPARK' | 'DROP' | 'MIST' | 'EMBER';

      interface Point {
        x: number;
        y: number;
        z?: number;
      }

      interface Particle {
        x: number;
        y: number;
        vx: number;
        vy: number;
        life: number;
        maxLife: number;
        size: number;
        color: string;
        element: ElementType | ComboType;
        type: ParticleType;
        angle: number;
        angularVelocity: number;
      }

      interface HandData {
        wrist: Point;
        indexTip: Point;
        middleTip: Point;
        ringTip: Point;
        pinkyTip: Point;
        thumbTip: Point;
        indexBase: Point; 
        middleBase: Point;
        ringBase: Point;
        pinkyBase: Point;
        isOpen: boolean;
        gesture: ElementType;
        opacity: number;
        middleBase: Point;
      }

      interface Theme {
        primary: string;
        secondary: string;
        core: string;
        shadow: string;
        background: string;
      }

      // --- UTILS & GEOMETRY ---

      const THEMES: Record<ElementType, Theme> = {
        NEUTRAL: { primary: '#FFA014', secondary: '#FFC832', core: '#FFFFFF', shadow: '#FFA014', background: '#121212' }, 
        FIRE: { primary: '#FF4500', secondary: '#FF8C00', core: '#FFFF00', shadow: '#FF0000', background: '#220a05' }, 
        WATER: { primary: '#1E90FF', secondary: '#00BFFF', core: '#E0FFFF', shadow: '#0000FF', background: '#051022' }, 
        THUNDER: { primary: '#9400D3', secondary: '#FF00FF', core: '#FFFFE0', shadow: '#4B0082', background: '#150522' }, 
        WIND: { primary: '#00FA9A', secondary: '#98FB98', core: '#F0FFF0', shadow: '#006400', background: '#051812' }, 
      };

      const drawRuneRing = (
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        radius: number,
        rotation: number,
        theme: Theme
      ) => {
        const segments = 24;
        ctx.strokeStyle = theme.primary;
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, y, radius * 0.85, 0, Math.PI * 2);
        ctx.stroke();

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        for (let i = 0; i < segments; i++) {
          const angle = (Math.PI * 2) / segments;
          ctx.save();
          ctx.rotate(i * angle);
          ctx.translate(radius * 0.925, 0); 

          const seed = i * 13.37;
          const size = radius * 0.05;

          ctx.beginPath();
          ctx.moveTo(-size, -size + Math.sin(seed) * size);
          ctx.lineTo(size, size - Math.cos(seed) * size);
          ctx.moveTo(-size, size);
          ctx.lineTo(size + Math.sin(seed * 2) * 5, -size);
          if (i % 3 === 0) ctx.rect(-size / 2, -size / 2, size, size);
          
          ctx.strokeStyle = theme.secondary;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          ctx.restore();
        }
        ctx.restore();
      };

      const drawSacredGeometry = (
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        radius: number,
        rotation: number,
        theme: Theme
      ) => {
        ctx.strokeStyle = theme.primary;
        ctx.lineWidth = 3;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const theta = (i * 2 * Math.PI) / 3;
          const px = radius * Math.cos(theta);
          const py = radius * Math.sin(theta);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const theta = (i * 2 * Math.PI) / 3 + Math.PI; 
          const px = radius * Math.cos(theta);
          const py = radius * Math.sin(theta);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(0, 0, radius * 0.5, 0, Math.PI * 2);
        ctx.strokeStyle = theme.secondary;
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      };

      const drawSquareLayer = (
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        radius: number,
        rotation: number,
        theme: Theme
      ) => {
        ctx.strokeStyle = theme.secondary;
        ctx.lineWidth = 4;
        
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        
        ctx.beginPath();
        const size = radius;
        ctx.rect(-size / 2, -size / 2, size, size);
        ctx.stroke();

        ctx.fillStyle = theme.core;
        const cornerSize = 4;
        ctx.fillRect(-size / 2 - cornerSize, -size / 2 - cornerSize, cornerSize * 2, cornerSize * 2);
        ctx.fillRect(size / 2 - cornerSize, -size / 2 - cornerSize, cornerSize * 2, cornerSize * 2);
        ctx.fillRect(size / 2 - cornerSize, size / 2 - cornerSize, cornerSize * 2, cornerSize * 2);
        ctx.fillRect(-size / 2 - cornerSize, size / 2 - cornerSize, cornerSize * 2, cornerSize * 2);

        ctx.restore();
      };

      const drawPentagram = (
        ctx: CanvasRenderingContext2D,
        x: number,
        y: number,
        radius: number,
        rotation: number,
        pulse: number,
        theme: Theme
      ) => {
        const r = radius * (0.8 + pulse * 0.2); 
        ctx.strokeStyle = theme.core;
        ctx.lineWidth = 2 + pulse * 2;
        ctx.shadowBlur = 10 + pulse * 10;
        ctx.shadowColor = theme.shadow;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const theta = (i * 4 * Math.PI) / 5 - Math.PI / 2;
          const px = r * Math.cos(theta);
          const py = r * Math.sin(theta);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        
        ctx.shadowBlur = 0; 
        ctx.restore();
      };

      // --- COMPONENTS ---

      // Handle ESM/CommonJS interop for react-webcam
      const Webcam = (WebcamModule).default || WebcamModule;

      interface MagicOverlayProps {
        width: number;
        height: number;
      }

      const COMBO_THEMES: Record<string, Theme> = {
        'BLIZZARD': { primary: '#00FFFF', secondary: '#E0FFFF', core: '#FFFFFF', shadow: '#008B8B', background: '#0a1a20' }, 
        'PLASMA': { primary: '#FF00FF', secondary: '#00FFFF', core: '#FFFFFF', shadow: '#9400D3', background: '#1a051a' }, 
        'STEAM': { primary: '#F0F8FF', secondary: '#B0C4DE', core: '#FFFFFF', shadow: '#778899', background: '#10151a' }, 
        'TEMPEST': { primary: '#000080', secondary: '#8A2BE2', core: '#FFFF00', shadow: '#191970', background: '#05051a' }, 
        'INFERNO': { primary: '#FF0000', secondary: '#FF4500', core: '#FFFF00', shadow: '#8B0000', background: '#2a0500' }, 
        'VOID': { primary: '#000000', secondary: '#4B0082', core: '#FFFFFF', shadow: '#9400D3', background: '#000000' }, 
      };

      const ELEMENT_NAMES_CN: Record<string, string> = {
          'NEUTRAL': 'Á≠âÂæÖÊñΩÊ≥ï...',
          'FIRE': 'üî• ÁÉàÁÑ∞ÊúØ (FIRE)',
          'WATER': 'üíß Âî§Èõ®ÊúØ (WATER)',
          'THUNDER': '‚ö° Èõ∑ÈúÜÊúØ (THUNDER)',
          'WIND': 'üå™Ô∏è ÁñæÈ£éÊúØ (WIND)',
          'BLIZZARD': '‚ùÑÔ∏è ÊûÅÂØíÈ£éÊö¥ (BLIZZARD)',
          'PLASMA': '‚öõÔ∏è Á≠âÁ¶ªÂ≠êÁ†¥ (PLASMA)',
          'STEAM': '‚ô®Ô∏è ÁÅºÁÉ≠Ëí∏Ê±Ω (STEAM)',
          'TEMPEST': '‚õàÔ∏è Èõ∑Êö¥È£éÁúº (TEMPEST)',
          'INFERNO': 'üåã Âú∞Áã±ÁÉàÁÅ´ (INFERNO)',
          'VOID': 'üåå ËôöÁ©∫Â•áÁÇπ (VOID)'
      };

      const getCombo = (g1: ElementType, g2: ElementType): string | null => {
          const sorted = [g1, g2].sort().join('_');
          switch(sorted) {
              case 'WATER_WIND': return 'BLIZZARD';
              case 'FIRE_WIND': return 'PLASMA';
              case 'FIRE_WATER': return 'STEAM';
              case 'THUNDER_WATER': return 'TEMPEST';
              case 'FIRE_FIRE': return 'INFERNO';
              case 'THUNDER_THUNDER': return 'VOID';
              default: return null;
          }
      };

      const MagicOverlay: React.FC<MagicOverlayProps> = ({ width, height }) => {
        const webcamRef = useRef(null);
        const canvasRef = useRef(null);
        const requestRef = useRef(0);
        const particlesRef = useRef([]);
        const handDataRef = useRef([]);
        const [currentElement, setCurrentElement] = useState('NEUTRAL');
        const [isModelLoaded, setIsModelLoaded] = useState(false);
        const [loadingError, setLoadingError] = useState(null);
        const [debugInfo, setDebugInfo] = useState("ÂàùÂßãÂåñÁ≥ªÁªü...");
        const [hasStarted, setHasStarted] = useState(false);
        const [showControls, setShowControls] = useState(true);

        // Settings State
        const [settings, setSettings] = useState({
            speed: 1.5,   // Base speed multiplier
            count: 1.2,   // Particle count multiplier
            glow: 1.2,    // Glow/Size intensity
        });
        
        // Settings Ref (for access inside animation loop without stale closures)
        const settingsRef = useRef(settings);
        useEffect(() => { settingsRef.current = settings; }, [settings]);

        // Visual Feedback State
        const highlightRef = useRef(0);
        const prevElementRef = useRef('NEUTRAL');
        const activeComboRef = useRef(null);
        
        // Audio Context
        const audioContextRef = useRef(null);
        const noiseBufferRef = useRef(null);

        // Get current Theme for background
        const currentTheme = activeComboRef.current 
          ? COMBO_THEMES[activeComboRef.current] 
          : (THEMES[currentElement] || THEMES['NEUTRAL']);

        useEffect(() => {
          const AudioContextClass = (window).AudioContext || (window).webkitAudioContext;
          if (AudioContextClass) {
              const ctx = new AudioContextClass();
              audioContextRef.current = ctx;

              const bufferSize = ctx.sampleRate * 2; 
              const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
              const data = buffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++) {
                  data[i] = Math.random() * 2 - 1;
              }
              noiseBufferRef.current = buffer;
          }
        }, []);

        const startExperience = () => {
            setHasStarted(true);
            if (audioContextRef.current?.state === 'suspended') {
                audioContextRef.current.resume();
            }
        };

        const playChime = useCallback((element) => {
          const ctx = audioContextRef.current;
          if (!ctx || !noiseBufferRef.current) return;
          if (ctx.state === 'suspended') ctx.resume().catch(console.error);

          const now = ctx.currentTime;
          const masterGain = ctx.createGain();
          masterGain.connect(ctx.destination);
          masterGain.gain.setValueAtTime(0.3, now); 

          const playNoise = (filterType, freqStart, freqEnd, duration, vol = 1, delay = 0) => {
              const src = ctx.createBufferSource();
              src.buffer = noiseBufferRef.current;
              src.loop = true;
              const filter = ctx.createBiquadFilter();
              filter.type = filterType;
              filter.frequency.setValueAtTime(freqStart, now + delay);
              filter.frequency.exponentialRampToValueAtTime(freqEnd, now + delay + duration);
              filter.Q.value = 1;
              const amp = ctx.createGain();
              amp.gain.setValueAtTime(0, now + delay);
              amp.gain.linearRampToValueAtTime(vol, now + delay + 0.05);
              amp.gain.exponentialRampToValueAtTime(0.01, now + delay + duration);
              src.connect(filter);
              filter.connect(amp);
              amp.connect(masterGain);
              src.start(now + delay);
              src.stop(now + delay + duration + 0.2);
          };

          const playTone = (type, freqStart, freqEnd, duration, vol = 1, delay = 0) => {
              const osc = ctx.createOscillator();
              osc.type = type;
              osc.frequency.setValueAtTime(freqStart, now + delay);
              if (freqStart !== freqEnd) osc.frequency.exponentialRampToValueAtTime(freqEnd, now + delay + duration);
              const amp = ctx.createGain();
              amp.gain.setValueAtTime(0, now + delay);
              amp.gain.linearRampToValueAtTime(vol, now + delay + 0.05);
              amp.gain.exponentialRampToValueAtTime(0.01, now + delay + duration);
              osc.connect(amp);
              amp.connect(masterGain);
              osc.start(now + delay);
              osc.stop(now + delay + duration + 0.2);
          };

          switch (element) {
              case 'FIRE': playNoise('lowpass', 500, 100, 1.0, 0.5); playTone('sawtooth', 80, 120, 0.8, 0.2); break;
              case 'WATER': playNoise('bandpass', 800, 300, 0.6, 0.4); playTone('sine', 600, 300, 0.4, 0.3, 0.1); break;
              case 'WIND': playNoise('lowpass', 200, 800, 0.4, 0.3); playNoise('highpass', 400, 1000, 0.5, 0.2, 0.1); break;
              case 'THUNDER': playTone('sawtooth', 800, 50, 0.3, 0.2); playNoise('lowpass', 1000, 50, 1.2, 0.6, 0.1); break;
              case 'BLIZZARD': playNoise('highpass', 1000, 3000, 1.5, 0.4); playTone('sine', 1500, 2000, 0.3, 0.1, 0.1); break;
              case 'INFERNO': playNoise('lowpass', 800, 50, 1.5, 0.8); playTone('square', 60, 40, 1.5, 0.2); break;
              case 'TEMPEST': playNoise('lowpass', 200, 50, 2.0, 0.8); playTone('sawtooth', 1200, 100, 0.5, 0.2, 0.1); playNoise('bandpass', 1000, 500, 1.0, 0.3); break;
              case 'VOID': playTone('sine', 50, 40, 2.5, 0.6); playNoise('bandpass', 100, 200, 2.5, 0.4); playTone('sine', 300, 290, 1.0, 0.1, 0.5); break;
              case 'PLASMA': playTone('sawtooth', 200, 800, 1.0, 0.2); playNoise('bandpass', 400, 1200, 1.0, 0.4); break;
              case 'STEAM': playNoise('highpass', 500, 1000, 1.0, 0.3); break;
              default: playTone('triangle', 440, 880, 0.3, 0.1);
          }
        }, []);

        const detectGesture = (landmarks, videoWidth, videoHeight) => {
          const mapPt = (idx) => ({ x: (1 - landmarks[idx].x) * videoWidth, y: landmarks[idx].y * videoHeight });
          const wrist = mapPt(0);
          const indexTip = mapPt(8);
          const middleTip = mapPt(12);
          const middleMCP = mapPt(9);
          
          // Optimized Distances
          const distSq = (p1, p2) => (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
          const isFingerOpen = (tip, mcp) => distSq(tip, wrist) > distSq(mcp, wrist) * 1.2;

          const isPointingDown = wrist.y < middleMCP.y;
          if (isPointingDown) return 'WATER';

          let openCount = 0;
          if (isFingerOpen(indexTip, mapPt(5))) openCount++;
          if (isFingerOpen(middleTip, mapPt(9))) openCount++;
          if (isFingerOpen(mapPt(16), mapPt(13))) openCount++;
          if (isFingerOpen(mapPt(20), mapPt(17))) openCount++;

          if (openCount >= 4) return 'FIRE';
          if (openCount >= 2) return 'WIND';
          return 'THUNDER';
        };

        const drawSkeleton = (ctx, hand) => {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
            ctx.lineWidth = 1.5;
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            const points = [hand.wrist, hand.indexBase, hand.indexTip, hand.middleBase, hand.middleTip, hand.ringBase, hand.ringTip, hand.pinkyBase, hand.pinkyTip, hand.thumbTip];
            
            const drawLine = (p1, p2) => { ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); }
            drawLine(hand.wrist, hand.indexBase); drawLine(hand.indexBase, hand.indexTip);
            drawLine(hand.wrist, hand.middleBase); drawLine(hand.middleBase, hand.middleTip);
            drawLine(hand.wrist, hand.pinkyBase); drawLine(hand.pinkyBase, hand.pinkyTip);

            points.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2); ctx.fill(); });
        };

        const onResults = useCallback((results) => {
          const videoWidth = width;
          const videoHeight = height;

          if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            setDebugInfo(`‚ö° Á≥ªÁªüÂ∞±Áª™ | Ê£ÄÊµãÂà∞ ${results.multiHandLandmarks.length} Âè™Êâã`);
            const newHandData = results.multiHandLandmarks.map((landmarks) => {
              const gesture = detectGesture(landmarks, videoWidth, videoHeight);
              const mapPt = (idx) => ({ x: (1 - landmarks[idx].x) * videoWidth, y: landmarks[idx].y * videoHeight });
              return {
                wrist: mapPt(0), indexTip: mapPt(8), middleTip: mapPt(12), ringTip: mapPt(16), pinkyTip: mapPt(20), thumbTip: mapPt(4),
                indexBase: mapPt(5), middleBase: mapPt(9), ringBase: mapPt(13), pinkyBase: mapPt(17),
                isOpen: gesture !== 'THUNDER', gesture, opacity: 1,
                middleBase: mapPt(9) // Center point for combo calculations
              };
            });
            
            handDataRef.current = newHandData;
            let newElement = 'NEUTRAL';
            let activeCombo = null;

            if (newHandData.length === 2) {
                const g1 = newHandData[0].gesture;
                const g2 = newHandData[1].gesture;
                if (g1 !== 'NEUTRAL' && g2 !== 'NEUTRAL') activeCombo = getCombo(g1, g2);
            }

            if (activeCombo) newElement = activeCombo;
            else {
                const activeHand = newHandData.find(h => h.gesture !== 'NEUTRAL');
                if (activeHand) newElement = activeHand.gesture;
            }
            activeComboRef.current = activeCombo;

            if (newElement !== prevElementRef.current) {
                if (newElement !== 'NEUTRAL') { highlightRef.current = 1.0; playChime(newElement); }
                prevElementRef.current = newElement;
            }
            setCurrentElement(newElement);
          } else {
            handDataRef.current = [];
            setDebugInfo("üîç Ê≠£Âú®ÊêúÁ¥¢ÊâãÈÉ®‰ø°Âè∑...");
            activeComboRef.current = null;
            if (prevElementRef.current !== 'NEUTRAL') { prevElementRef.current = 'NEUTRAL'; setCurrentElement('NEUTRAL'); }
          }
        }, [width, height, playChime]);

        useEffect(() => {
          let hands = null;
          let isActive = true;
          let frameId;
          let lastVideoTime = -1;
          
          // PINNED VERSION to ensure compatibility between JS and WASM
          const MP_VERSION = "0.4.1675469240";

          // ROBUST SCRIPT LOADING for React Strict Mode
          const loadScript = (src) => {
            return new Promise((resolve, reject) => {
              if (window.Hands) {
                resolve();
                return;
              }
              
              let script = document.querySelector(`script[src="${src}"]`);
              if (script) {
                  const interval = setInterval(() => {
                      if (window.Hands) {
                          clearInterval(interval);
                          resolve();
                      }
                  }, 100);
                  return;
              }

              script = document.createElement('script');
              script.src = src;
              script.crossOrigin = 'anonymous';
              script.onload = () => {
                  if (window.Hands) {
                      resolve();
                  } else {
                      const interval = setInterval(() => {
                          if (window.Hands) {
                              clearInterval(interval);
                              resolve();
                          }
                      }, 100);
                  }
              };
              script.onerror = (e) => reject(e);
              document.head.appendChild(script);
            });
          };

          const initHands = async () => {
             try {
                setDebugInfo("Ê≠£Âú®Âä†ËΩΩ AI Ê†∏ÂøÉ (1/3)...");
                await loadScript(`https://cdn.jsdelivr.net/npm/@mediapipe/hands@${MP_VERSION}/hands.js`);
                
                if (!(window).Hands) {
                    throw new Error("Hands library loaded but window.Hands is undefined.");
                }

                setDebugInfo("ÂàùÂßãÂåñËßÜËßâÊ®°Âûã (2/3)...");
                hands = new (window).Hands({ 
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@${MP_VERSION}/${file}` 
                });
                
                hands.setOptions({ 
                    maxNumHands: 2, 
                    modelComplexity: 1, 
                    minDetectionConfidence: 0.5, 
                    minTrackingConfidence: 0.5 
                });
                
                hands.onResults(onResults);
                
                setDebugInfo("ÂêØÂä®ËßÜÈ¢ëÊµÅ (3/3)...");
                setIsModelLoaded(true);
                
                const processVideo = async () => {
                  if (!isActive) return;
                  if (webcamRef.current && webcamRef.current.video && webcamRef.current.video.readyState === 4) {
                      const video = webcamRef.current.video;
                      if (video.videoWidth > 0 && video.videoHeight > 0) {
                          if (video.currentTime !== lastVideoTime) {
                              lastVideoTime = video.currentTime;
                              try { await hands.send({ image: video }); } catch (e) { 
                                  // Ignore transient errors during initialization
                              }
                          }
                      }
                  }
                  frameId = requestAnimationFrame(processVideo);
                };
                processVideo();

             } catch (error) {
                console.error("Initialization Error:", error);
                setLoadingError("AI Ê®°ÂûãÂä†ËΩΩÂ§±Ë¥•: " + error.message);
                setDebugInfo("Á≥ªÁªüÈîôËØØ");
             }
          };

          setTimeout(initHands, 100);

          return () => { isActive = false; if (frameId) cancelAnimationFrame(frameId); if (hands) hands.close(); };
        }, [onResults]);

        // --- PHYSICS ENGINE (Optimized) ---
        const updateParticles = (ctx, width, height, centerX, centerY) => {
          // PERFORMANCE: Limit global composite changes inside loop
          ctx.shadowBlur = 0; // Disable shadow blur for particles to increase FPS
          
          // Get current settings from ref to avoid stale closures in animation loop
          const { glow } = settingsRef.current;

          for (let i = particlesRef.current.length - 1; i >= 0; i--) {
            const p = particlesRef.current[i];
            
            // Speed Increase & Drag Logic
            if (p.element === 'WIND' || p.element === 'BLIZZARD') {
                // Less drag for wind elements so they travel further
                p.vx *= 0.995; 
                p.vy *= 0.995;
            } else {
                // Standard drag
                p.vx *= 0.98; 
                p.vy *= 0.98;
            }

            switch (p.element) {
                case 'WIND':
                case 'BLIZZARD':
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    const dist = Math.sqrt(dx*dx + dy*dy) + 1;
                    const angle = Math.atan2(dy, dx);
                    p.vx += Math.cos(angle + Math.PI/2) * 2.5; // Faster rotation
                    p.vy += Math.sin(angle + Math.PI/2) * 2.5;
                    p.vx -= (dx / dist) * 0.8;
                    p.vy -= (dy / dist) * 0.8;
                    p.angle += p.angularVelocity * 1.5; 
                    break;

                case 'WATER':
                case 'STEAM':
                    p.vy += 1.5; // Heavier gravity
                    p.x += Math.sin(p.life * 0.2) * 1.0;
                    break;

                case 'THUNDER':
                case 'TEMPEST':
                case 'VOID':
                    p.vx += (Math.random() - 0.5) * 6; // More chaos
                    p.vy += (Math.random() - 0.5) * 6;
                    if (Math.random() < 0.15) {
                        p.x += (Math.random() - 0.5) * 40;
                        p.y += (Math.random() - 0.5) * 40;
                    }
                    break;

                case 'FIRE':
                case 'INFERNO':
                    p.vy -= 1.5; // Increased upward velocity (was 1.0)
                    p.vx += (Math.random() - 0.5) * 2.0;
                    p.size *= 0.95; 
                    break;
                    
                default:
                    p.vy -= 0.2;
            }

            p.x += p.vx;
            p.y += p.vy;
            p.life -= 1;
            if (p.element !== 'FIRE') p.size *= 0.98;

            if (p.life <= 0 || p.size < 0.1 || p.y > height + 50 || p.y < -50 || p.x < -50 || p.x > width + 50) {
              particlesRef.current.splice(i, 1);
            } else {
              ctx.save();
              
              // --- DYNAMIC SHADOWS (Fake 3D) ---
              if (p.size > 2) {
                   const shadowOffsetX = (p.x - centerX) * 0.05;
                   const shadowOffsetY = (p.y - centerY) * 0.05;
                   ctx.fillStyle = "rgba(0,0,0,0.3)";
                   ctx.beginPath();
                   ctx.arc(p.x + shadowOffsetX, p.y + shadowOffsetY, p.size * glow, 0, Math.PI*2);
                   ctx.fill();
              }

              // Calculate opacity
              let alpha = Math.min(1, p.life / 10, (p.maxLife - p.life) / 5);
              
              // Add flickering for small FIRE embers
              if ((p.element === 'FIRE' || p.element === 'INFERNO') && p.size < 3.5 && p.type === 'EMBER') {
                   alpha *= (0.5 + Math.random() * 0.5);
              }
              
              ctx.globalAlpha = alpha;
              
              // Apply GLOW multiplier to size or line width
              const renderSize = p.size * glow;

              if (p.type === 'LEAF') {
                  ctx.translate(p.x, p.y);
                  ctx.rotate(p.angle);
                  ctx.fillStyle = p.color;
                  ctx.beginPath();
                  ctx.ellipse(0, 0, renderSize, renderSize * 0.4, 0, 0, Math.PI * 2);
                  ctx.fill();
              } 
              else if (p.type === 'DROP') {
                  ctx.strokeStyle = p.color;
                  ctx.lineWidth = 2.5 * glow;
                  ctx.lineCap = 'round';
                  ctx.beginPath();
                  ctx.moveTo(p.x, p.y);
                  ctx.lineTo(p.x - p.vx * 1.5, p.y - p.vy * 4); // Longer streaks
                  ctx.stroke();
              }
              else if (p.type === 'SPARK') {
                  ctx.strokeStyle = p.color;
                  ctx.lineWidth = 2 * glow;
                  ctx.beginPath();
                  ctx.moveTo(p.x - p.vx, p.y - p.vy);
                  ctx.lineTo(p.x + p.vx, p.y + p.vy);
                  ctx.stroke();
              }
              else {
                  ctx.fillStyle = p.color;
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, renderSize, 0, Math.PI * 2);
                  ctx.fill();
              }
              ctx.restore();
            }
          }
        };

        const spawnParticles = (x, y, element, theme) => {
          // Get current settings
          const { speed: speedMulti, count: countMulti } = settingsRef.current;

          const isCombo = activeComboRef.current !== null;
          let baseCount = isCombo ? 10 : 3;
          let count = Math.ceil(baseCount * countMulti);
          
          // Limit max particles per frame to prevent freezing
          count = Math.min(count, 50);

          for (let i = 0; i < count; i++) {
              // Defaults
              let type = 'ORB';
              // Increased base speed multiplied by user setting
              let speed = (Math.random() * 8 + 4) * speedMulti; 
              let spread = 30;
              let pColor = Math.random() > 0.5 ? theme.primary : theme.secondary;
              let pSize = 4 + Math.random() * 6;
              let pLife = 30 + Math.random() * 30;
              
              // Determine properties based on element (MIXING logic moved inside loop)
              if (element === 'WIND' || element === 'BLIZZARD') {
                  type = Math.random() > 0.5 ? 'LEAF' : 'MIST';
                  if (isCombo) pColor = Math.random() > 0.5 ? '#00FFFF' : '#F0FFF0';
                  else if (element === 'WIND') pColor = Math.random() > 0.5 ? '#00FFFF' : '#F0FFF0'; 
              } else if (element === 'WATER' || element === 'STEAM') {
                  type = Math.random() > 0.7 ? 'MIST' : 'DROP';
                  spread = 50; 
              } else if (element === 'THUNDER' || element === 'TEMPEST' || element === 'VOID') {
                  type = 'SPARK';
                  speed = 12 * speedMulti; // Very fast sparks
                  if (element === 'THUNDER') pColor = Math.random() > 0.5 ? '#FFFF00' : '#9400D3';
              } else if (element === 'FIRE' || element === 'INFERNO') {
                  // FIRE LOGIC MIX: Mist (Smoke), Ember (Flame), Ember (Sparks)
                  const r = Math.random();
                  if (r < 0.3) {
                       // Fast, small, bright embers (New flickering particles)
                       type = 'EMBER';
                       pColor = Math.random() > 0.5 ? '#FFD700' : '#FFFFFF'; // Gold/White
                       pSize = 1 + Math.random() * 3;
                       pLife = 15 + Math.random() * 20; // Shorter life
                       speed *= 1.5; // Faster
                  } else if (r < 0.6) {
                       type = 'MIST'; // Smoke
                  } else {
                       type = 'EMBER'; // Main flame
                  }
              }

              const angle = Math.random() * Math.PI * 2;
              let vx = Math.cos(angle) * speed;
              let vy = Math.sin(angle) * speed;
            
              if (element === 'WATER' || element === 'STEAM') { vx *= 0.3; vy = Math.random() * 5 * speedMulti + 5; } 
              // Embers float up faster
              if ((element === 'FIRE' || element === 'INFERNO') && pSize < 4 && type === 'EMBER') {
                  vy -= 2.0; 
              }
            
              let spawnX = x;
              let spawnY = y;
              
              // Custom spread logic
              if (element === 'WATER' || element === 'STEAM') {
                   spawnX = x + (Math.random() - 0.5) * spread;
                   spawnY = y + (Math.random() - 0.5) * spread;
              } else {
                   spawnX = x + (Math.random() - 0.5) * spread;
                   spawnY = y + (Math.random() - 0.5) * spread;
              }
            
              if (isCombo || element === 'WATER') {
                  spawnX = Math.random() * width;
                  if (element === 'WATER' || element === 'TEMPEST') {
                     spawnY = Math.random() * -100;
                  } else {
                     spawnY = Math.random() * height;
                  }
              }

              particlesRef.current.push({
                  x: spawnX,
                  y: spawnY,
                  vx, vy,
                  life: pLife,
                  maxLife: 60,
                  size: pSize,
                  color: pColor,
                  element: element,
                  type,
                  angle: Math.random() * Math.PI * 2,
                  angularVelocity: (Math.random() - 0.5) * 0.4
              });
          }
        };

        const animate = useCallback((time) => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d', { alpha: false }); // Optimization: alpha false
          if (!ctx) return;

          // HIGH DPI SCALING
          const dpr = window.devicePixelRatio || 1;
          if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
              canvas.width = width * dpr;
              canvas.height = height * dpr;
          }
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

          // 1. Draw Background (Clear)
          // Use the Theme Background variable directly for canvas fill
          const theme = activeComboRef.current 
              ? COMBO_THEMES[activeComboRef.current] 
              : (THEMES[currentElement] || THEMES['NEUTRAL']);
          
          // CRITICAL FIX: Reset composite operation to default before clearing/drawing background
          // This prevents the 'lighter' blending from accumulating indefinitely into white.
          ctx.globalCompositeOperation = 'source-over';
              
          ctx.fillStyle = theme.background;
          ctx.fillRect(0, 0, width, height);

          if (highlightRef.current > 0.01) highlightRef.current *= 0.925; // approx 1s duration
          else highlightRef.current = 0;
          const flash = highlightRef.current;

          // --- SCREEN BORDER FLASH EFFECT ---
          if (flash > 0.01) {
              ctx.save();
              ctx.globalCompositeOperation = 'lighter';
              ctx.strokeStyle = theme.primary;
              ctx.lineWidth = 30 * flash; // Border gets thinner as it fades
              ctx.shadowBlur = 40;
              ctx.shadowColor = theme.secondary;
              ctx.globalAlpha = flash; // Fade out opacity
              
              // Draw Outer Border
              ctx.strokeRect(0, 0, width, height);
              
              // Draw Inner Decorative Border
              ctx.strokeStyle = theme.core;
              ctx.lineWidth = 2;
              ctx.globalAlpha = flash * 0.7;
              const inset = 20 * (2 - flash); // Inset animation
              ctx.strokeRect(inset, inset, width - inset * 2, height - inset * 2);
              
              ctx.restore();
          }

          let lastCenterX = width / 2;
          let lastCenterY = height / 2;
          const t = time * 0.001;
          const comboName = activeComboRef.current;

          // --- DETERMINE CENTER ---
          if (comboName && handDataRef.current.length === 2) {
               lastCenterX = (handDataRef.current[0].middleBase.x + handDataRef.current[1].middleBase.x) / 2;
               lastCenterY = (handDataRef.current[0].middleBase.y + handDataRef.current[1].middleBase.y) / 2;
          } else if (handDataRef.current.length > 0) {
              // Find active hand or just first hand
              const active = handDataRef.current.find(h => h.gesture !== 'NEUTRAL') || handDataRef.current[0];
              lastCenterX = active.middleBase.x;
              lastCenterY = active.middleBase.y;
          }

          // 2. Geometry & Particles
          // Enable additive blending for glowing magic effects
          ctx.globalCompositeOperation = 'lighter'; 
          
          if (comboName && handDataRef.current.length === 2) {
              // --- COMBO MODE ---
              const h1 = handDataRef.current[0];
              const h2 = handDataRef.current[1];
              
              const midX = lastCenterX;
              const midY = lastCenterY;

              ctx.save();
              ctx.beginPath();
              ctx.moveTo(h1.middleBase.x, h1.middleBase.y);
              ctx.lineTo(h2.middleBase.x, h2.middleBase.y);
              ctx.strokeStyle = theme.primary;
              ctx.lineWidth = 20 + Math.sin(t * 10) * 5; 
              ctx.lineCap = 'round';
              ctx.shadowBlur = 20; // Reduced blur
              ctx.shadowColor = theme.secondary;
              ctx.globalAlpha = 0.4;
              ctx.stroke();
              ctx.restore();

              ctx.save();
              ctx.beginPath();
              ctx.moveTo(h1.middleBase.x, h1.middleBase.y);
              ctx.lineTo(h2.middleBase.x, h2.middleBase.y);
              ctx.strokeStyle = '#FFFFFF';
              ctx.lineWidth = 3;
              ctx.setLineDash([10, 40]);
              ctx.lineDashOffset = -t * 200; 
              ctx.globalCompositeOperation = 'overlay';
              ctx.stroke();
              ctx.restore();

              // Arcs
              ctx.save();
              ctx.beginPath();
              ctx.moveTo(h1.middleBase.x, h1.middleBase.y);
              const dist = Math.hypot(h2.middleBase.x - h1.middleBase.x, h2.middleBase.y - h1.middleBase.y);
              const angle = Math.atan2(h2.middleBase.y - h1.middleBase.y, h2.middleBase.x - h1.middleBase.x);
              for(let i=0; i<=10; i++) { // Reduced segments
                   const p = i/10;
                   const perp = Math.sin(p * Math.PI * 4 + t * 20) * (15 + Math.random() * 5);
                   const bx = h1.middleBase.x + (h2.middleBase.x - h1.middleBase.x) * p + Math.cos(angle + Math.PI/2)*perp;
                   const by = h1.middleBase.y + (h2.middleBase.y - h1.middleBase.y) * p + Math.sin(angle + Math.PI/2)*perp;
                   ctx.lineTo(bx, by);
              }
              ctx.strokeStyle = theme.secondary;
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.restore();

              ctx.globalAlpha = 1;
              drawRuneRing(ctx, midX, midY, 180, t, theme);
              drawSacredGeometry(ctx, midX, midY, 140, -t * 2, theme);
              drawSquareLayer(ctx, midX, midY, 100, t * 3, theme);
              drawPentagram(ctx, midX, midY, 60, -t, 1, theme);

              spawnParticles(midX, midY, comboName, theme);
              
              handDataRef.current.forEach(h => {
                   drawSkeleton(ctx, h);
                   const auraSize = 50 + Math.sin(t * 20) * 10;
                   const grad = ctx.createRadialGradient(h.middleBase.x, h.middleBase.y, 10, h.middleBase.x, h.middleBase.y, auraSize);
                   grad.addColorStop(0, theme.core);
                   grad.addColorStop(0.4, theme.primary);
                   grad.addColorStop(1, 'rgba(0,0,0,0)');
                   ctx.save();
                   ctx.fillStyle = grad;
                   ctx.globalAlpha = 0.5;
                   ctx.beginPath();
                   ctx.arc(h.middleBase.x, h.middleBase.y, auraSize, 0, Math.PI * 2);
                   ctx.fill();
                   ctx.restore();
                   drawRuneRing(ctx, h.middleBase.x, h.middleBase.y, 40, t*5, theme);
              });

          } else {
              // --- INDIVIDUAL MODE ---
              handDataRef.current.forEach((hand) => {
                 drawSkeleton(ctx, hand);
                 const element = hand.gesture;
                 const handTheme = (element !== 'NEUTRAL' && THEMES[element]) ? THEMES[element] : THEMES['NEUTRAL'];
                 const centerX = hand.middleBase.x; 
                 const centerY = hand.middleBase.y; 
                 
                 if (element !== 'NEUTRAL') {
                     if (flash > 0.05 && highlightRef.current > 0.05) {
                         ctx.save();
                         ctx.translate(centerX, centerY);
                         const waveSize = 120 + (1 - flash) * 100;
                         ctx.beginPath();
                         ctx.arc(0, 0, waveSize, 0, Math.PI * 2);
                         ctx.lineWidth = 10 * flash;
                         ctx.strokeStyle = handTheme.core;
                         ctx.shadowBlur = 20;
                         ctx.shadowColor = handTheme.secondary;
                         ctx.globalAlpha = flash;
                         ctx.stroke();
                         ctx.restore();
                     }

                     drawRuneRing(ctx, centerX, centerY, 120, t * 0.5, handTheme);
                     drawSacredGeometry(ctx, centerX, centerY, 90, -t * 1.5, handTheme);
                     drawSquareLayer(ctx, centerX, centerY, 65, t * 2.5, handTheme);
                     const pulse = Math.sin(time * 0.005) * 0.5 + 0.5;
                     drawPentagram(ctx, centerX, centerY, 40, t, pulse, handTheme);
                     
                     spawnParticles(centerX, centerY, element, handTheme);
                 } else {
                     ctx.globalAlpha = 0.3;
                     drawRuneRing(ctx, centerX, centerY, 50, t * 0.2, handTheme);
                 }
              });
          }

          updateParticles(ctx, width, height, lastCenterX, lastCenterY);
          requestRef.current = requestAnimationFrame(animate);
        }, [width, height, currentElement]);

        useEffect(() => {
          requestRef.current = requestAnimationFrame(animate);
          return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
        }, [animate]);

        return (
          <div className="relative w-full h-full overflow-hidden flex items-center justify-center font-sans">
              
              {/* Dynamic Background */}
              <div 
                  className="absolute inset-0 transition-colors duration-700 ease-in-out z-0"
                  style={{ backgroundColor: currentTheme.background }}
              />

              {/* Hidden Webcam */}
              <Webcam ref={webcamRef} audio={false} width={width} height={height} mirrored={true} screenshotFormat="image/jpeg" className="absolute opacity-0 pointer-events-none" />
              
              {/* Canvas Layer */}
              <canvas ref={canvasRef} style={{ width, height }} className="absolute top-0 left-0 z-10" />
              
              {!isModelLoaded && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-90 z-50">
                      <div className="flex flex-col items-center">
                          <div className="text-amber-500 font-mono text-xl animate-pulse tracking-widest mb-4">üîÆ Ê≠£Âú®Ê†°ÂáÜÈ≠îÊ≥ïÁª¥Â∫¶...</div>
                          {loadingError ? (
                              <div className="text-red-500 font-bold bg-black/50 p-2 rounded">{loadingError}</div>
                          ) : (
                              <div className="w-64 h-1 bg-gray-800 rounded-full overflow-hidden">
                                  <div className="h-full bg-amber-500 animate-[width_1s_ease-in-out_infinite]" style={{width: '50%'}}></div>
                              </div>
                          )}
                      </div>
                  </div>
              )}

              {!hasStarted && isModelLoaded && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black/60 z-50 cursor-pointer backdrop-blur-sm" onClick={startExperience}>
                      <div className="border border-amber-500/50 bg-black/80 p-8 rounded-lg text-center shadow-[0_0_30px_rgba(255,160,20,0.3)] hover:scale-105 transition-transform duration-300">
                          <h2 className="text-3xl font-bold text-amber-500 mb-2">ÂáÜÂ§áÂ∞±Áª™</h2>
                          <p className="text-white/80 mb-6">ÁÇπÂáªÂ±èÂπïÂºÄÂêØÁßòÊúØÂ∑•Âùä</p>
                          <button className="px-6 py-2 bg-amber-600 hover:bg-amber-500 text-black font-bold rounded">ËøõÂÖ•</button>
                      </div>
                  </div>
              )}

              {/* Dynamic Spell Name */}
              <div className="absolute top-20 left-0 w-full flex justify-center z-20 pointer-events-none">
                   <div className={`text-4xl md:text-5xl font-bold tracking-widest transition-all duration-300 drop-shadow-[0_0_15px_rgba(255,255,255,0.4)] px-8 py-2 rounded-full ${highlightRef.current > 0.1 ? 'scale-110 bg-black/20 backdrop-blur-sm' : ''} ${
                      currentElement === 'FIRE' ? 'text-orange-500' :
                      currentElement === 'WATER' ? 'text-blue-500' :
                      currentElement === 'WIND' ? 'text-cyan-300' :
                      currentElement === 'THUNDER' ? 'text-purple-500' : 
                      currentElement === 'INFERNO' ? 'text-red-600' :
                      currentElement === 'BLIZZARD' ? 'text-cyan-100' :
                      currentElement === 'VOID' ? 'text-violet-400' : 'text-amber-400'
                  }`}>
                      {ELEMENT_NAMES_CN[currentElement]}
                  </div>
              </div>
              
              {/* Toggle Controls Button */}
              <div className="absolute top-4 right-4 z-30">
                  <button 
                      onClick={() => setShowControls(!showControls)}
                      className="bg-black/40 border border-white/10 p-2 rounded hover:bg-white/10 transition-colors text-white/50 text-xs uppercase font-mono tracking-wider"
                  >
                      {showControls ? 'Hide Controls' : 'Show Controls'}
                  </button>
              </div>

              {/* Debug Info */}
              <div className="absolute top-12 right-4 z-20 text-right opacity-50 pointer-events-none">
                   <div className="text-xs text-amber-200 font-mono">{debugInfo}</div>
              </div>

              {/* PARTICLE CONTROLS PANEL */}
              {showControls && (
                  <div className="absolute top-20 right-4 z-30 w-64 bg-black/60 backdrop-blur-md border border-white/10 rounded-xl p-4 shadow-2xl animate-[fadeIn_0.3s_ease-out]">
                      <h3 className="text-amber-500 text-xs font-bold uppercase tracking-widest mb-4 border-b border-white/10 pb-2">Á≤íÂ≠êÂºïÊìéÂèÇÊï∞</h3>
                      
                      <div className="space-y-4">
                          <div>
                              <div className="flex justify-between text-xs text-white/70 mb-1">
                                  <span>ÈÄüÂ∫¶ (Velocity)</span>
                                  <span className="font-mono text-amber-400">{settings.speed.toFixed(1)}x</span>
                              </div>
                              <input 
                                  type="range" min="0.1" max="10.0" step="0.1" 
                                  value={settings.speed}
                                  onChange={(e) => setSettings({...settings, speed: parseFloat(e.target.value)})}
                                  className="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-amber-500"
                              />
                          </div>
                          
                          <div>
                              <div className="flex justify-between text-xs text-white/70 mb-1">
                                  <span>Êï∞Èáè (Density)</span>
                                  <span className="font-mono text-amber-400">{settings.count.toFixed(1)}x</span>
                              </div>
                              <input 
                                  type="range" min="0.1" max="5.0" step="0.1" 
                                  value={settings.count}
                                  onChange={(e) => setSettings({...settings, count: parseFloat(e.target.value)})}
                                  className="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-amber-500"
                              />
                          </div>
                          
                          <div>
                              <div className="flex justify-between text-xs text-white/70 mb-1">
                                  <span>ËæâÂÖâ (Glow)</span>
                                  <span className="font-mono text-amber-400">{settings.glow.toFixed(1)}x</span>
                              </div>
                              <input 
                                  type="range" min="0.5" max="3.0" step="0.1" 
                                  value={settings.glow}
                                  onChange={(e) => setSettings({...settings, glow: parseFloat(e.target.value)})}
                                  className="w-full h-1 bg-white/20 rounded-lg appearance-none cursor-pointer accent-amber-500"
                              />
                          </div>
                      </div>
                  </div>
              )}

              {/* Gesture Guide */}
              <div className="absolute bottom-0 left-0 w-full p-6 z-20">
                  <div className="max-w-4xl mx-auto bg-black/40 backdrop-blur-md border border-white/10 rounded-2xl p-4 shadow-2xl">
                      <div className="flex flex-wrap justify-center items-center gap-4 md:gap-8 text-white/90 text-sm font-medium">
                          <div className="flex items-center gap-3 bg-white/5 px-4 py-2 rounded-lg border border-white/5">
                              <span className="text-2xl">‚úã</span> 
                              <div className="flex flex-col leading-tight">
                                  <span className="text-orange-400 font-bold">ÁÅ´ÁÑ∞</span>
                                  <span className="text-[10px] text-gray-400">‰∫îÊåáÂº†ÂºÄ</span>
                              </div>
                          </div>
                          <div className="flex items-center gap-3 bg-white/5 px-4 py-2 rounded-lg border border-white/5">
                              <span className="text-2xl">üëá</span>
                              <div className="flex flex-col leading-tight">
                                  <span className="text-blue-400 font-bold">ÊµÅÊ∞¥</span>
                                  <span className="text-[10px] text-gray-400">ÊéåÂøÉÂêë‰∏ã</span>
                              </div>
                          </div>
                          <div className="flex items-center gap-3 bg-white/5 px-4 py-2 rounded-lg border border-white/5">
                              <span className="text-2xl">üëä</span>
                              <div className="flex flex-col leading-tight">
                                  <span className="text-purple-400 font-bold">Èõ∑ÈúÜ</span>
                                  <span className="text-[10px] text-gray-400">Êè°Á¥ßÊã≥Â§¥</span>
                              </div>
                          </div>
                          <div className="flex items-center gap-3 bg-white/5 px-4 py-2 rounded-lg border border-white/5">
                              <span className="text-2xl">‚úåÔ∏è</span>
                              <div className="flex flex-col leading-tight">
                                  <span className="text-teal-300 font-bold">ÁñæÈ£é</span>
                                  <span className="text-[10px] text-gray-400">È£üÊåá‰∏≠Êåá (Ââ™ÂàÄÊâã)</span>
                              </div>
                          </div>
                      </div>
                      <div className="text-center mt-3 text-xs text-amber-500/60 tracking-wider uppercase font-mono">
                          ‚ú¶ ÂèåÊâãÁªìÂç∞Ëß¶ÂèëÈ´òÈò∂Ê≥ïÊúØ ‚ú¶
                      </div>
                  </div>
              </div>
          </div>
        );
      };

      // --- APP COMPONENT ---

      const App = () => {
        const [dimensions, setDimensions] = useState({ width: 640, height: 480 });

        useEffect(() => {
          const handleResize = () => {
            setDimensions({
              width: window.innerWidth,
              height: window.innerHeight
            });
          };

          window.addEventListener('resize', handleResize);
          handleResize(); 

          return () => window.removeEventListener('resize', handleResize);
        }, []);

        return (
          <div className="w-screen h-screen bg-neutral-900 overflow-hidden relative">
            <MagicOverlay width={dimensions.width} height={dimensions.height} />
            
            <div className="absolute top-0 left-0 p-6 pointer-events-none z-30">
              <h1 className="text-3xl font-bold text-amber-500 tracking-tighter" style={{ textShadow: '0 0 15px #FFC832' }}>
                ÁßòÊúØÂ∑•Âùä
              </h1>
              <div className="w-16 h-1 bg-amber-500 mt-2 shadow-[0_0_10px_#FFA014]"></div>
            </div>
          </div>
        );
      };

      // --- ROOT RENDER ---
      
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
    <script type="module_" src="/index.tsx"></script>
  </body>
</html>
